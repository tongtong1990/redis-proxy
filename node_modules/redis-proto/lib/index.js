'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

// $FlowIgnore: Pending on facebook/flow#3495


exports.encode = encode;
exports.decodeProgressive = decodeProgressive;
exports.decodeGen = decodeGen;
exports.decode = decode;

var _buffer = require('buffer');

// NOTE: The reason we have encodeArray option is because redis protocol
// does not support nested arrays
function encode(request) {
  var encodeArray = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

  if (request === null) {
    return '$-1\r\n';
  }
  if (Array.isArray(request) && encodeArray) {
    var content = ['*' + request.length + '\r\n'];
    for (var i = 0, length = request.length; i < length; i++) {
      content.push(encode(request[i], false));
    }
    return content.join('');
  }
  var value = void 0;
  if ((typeof request === 'undefined' ? 'undefined' : _typeof(request)) === 'object' || typeof request === 'function') {
    value = {}.toString.call(request);
  } else {
    value = String(request);
  }
  return '$' + value.length + '\r\n' + value + '\r\n';
}

function decodeProgressive(content, startIndex) {
  var currentIndex = startIndex;
  var type = content.toString('utf8', currentIndex, currentIndex + 1);
  // +1 because type takes 1 character
  currentIndex++;

  if (type === '*') {
    // Array
    var lengthEnd = content.indexOf('\r\n', currentIndex);
    var length = parseInt(content.toString('utf8', currentIndex, lengthEnd), 10);
    // +2 because of \r\n after length ends
    currentIndex = lengthEnd + 2;

    var _value = [];
    for (var i = 0; i < length; i++) {
      var entry = decodeProgressive(content, currentIndex);
      currentIndex = entry.index;
      _value.push(entry.value);
    }
    return { index: currentIndex, value: _value };
  }

  if (type === '$') {
    // String or Null
    var _lengthEnd = content.indexOf('\r\n', currentIndex);
    var _length = parseInt(content.toString('utf8', currentIndex, _lengthEnd), 10);
    // +2 because of \r\n after length ends
    currentIndex = _lengthEnd + 2;

    var _value2 = void 0;
    if (_length === -1) {
      // Null
      _value2 = null;
    } else {
      // String
      _value2 = content.toString('utf8', currentIndex, currentIndex + _length);
      // +2 because of \r\n at the end of string
      currentIndex += _length + 2;
    }

    return { index: currentIndex, value: _value2 };
  }

  if (type === '+') {
    // Simple string
    var valueEnd = content.indexOf('\r\n', currentIndex);
    var _value3 = content.toString('utf8', currentIndex, valueEnd);
    // +2 because of \r\n at the end of simple string
    currentIndex = valueEnd + 2;

    return { index: currentIndex, value: _value3 };
  }

  if (type === ':') {
    // Integer
    var _valueEnd = content.indexOf('\r\n', currentIndex);
    var _value4 = parseInt(content.toString('utf8', currentIndex, _valueEnd), 10);
    // +2 because of \r\n at the end of simple string
    currentIndex = _valueEnd + 2;

    return { index: currentIndex, value: _value4 };
  }

  if (type === '-') {
    // Error
    var _valueEnd2 = content.indexOf('\r\n', currentIndex);
    var _value5 = content.toString('utf8', currentIndex, _valueEnd2);
    throw new Error(_value5);
  }

  throw new Error('Malformed Input');
}

function* decodeGen(givenContent) {
  var index = 0;
  var content = _buffer.Buffer.from(givenContent);

  for (;;) {
    var entry = decodeProgressive(content, index);
    index = entry.index;
    yield entry.value;
    if (index === content.length) {
      // We have read it all!
      break;
    }
  }
}

function decode(givenContent) {
  var index = 0;
  var value = [];
  var content = _buffer.Buffer.from(givenContent);

  for (;;) {
    var entry = decodeProgressive(content, index);
    index = entry.index;
    value.push(entry.value);
    if (index === content.length) {
      // We have read it all!
      break;
    }
  }

  return value;
}